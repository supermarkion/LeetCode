# Technical Prepartion

* Data structures:
	+ Linked Lists (solved)
	+ Binary Trees (solved)
	+ Tries (half-solved)
	+ Stacks (solved)
	+ Queues (solved)
	+ Vecotrs / ArrayLists (solved)
	+ Hash Tables (solved)

+ Algorithms:
	+ Breadth First Search (solved)
	+ Depth First Search (solved)
	+ BInary Search (solved)
	+ Merge Sort (solved)
	+ Quick Sort (solved)
	+ Tree Insert / Find /etc

+ Concepts:
	+ Bit Manipulation (half-solved)
	+ Singleton Design Pattern (half-solved)
	+ Factory Desgin Pattern (non-solved)
	+ Memory (Stack vs Heap) (non-solved)
	+ Recursion (solved)
	+ Big-O Time

* Code Test
	+ Extreme case: 0, negative, null, maximus, etc.
	+ User error: What happends if the user passes in null or a negative value?
	+ General cases: Test the normal case.

* Five Algorithm Approaches
	+ Examplify: Write out specific examples of the problem, and see if you can figure out a general rule.
	+ Pattern Matching: Consider what problems the algorithm is similar to, and figure out if you can modify the solution to develop an algorithm for this problem.
	+ Simplify & Generalize: Change a constraint (data type, size, etc) to simplify the problem. Then try to solve it. Once you have an algorithm for the “simplified” problem, generalize the problem again.
	+ Base Cae and Build: Solve the algorithm first for a base case (e.g., just one element). Then, try to solve it for elements one and two, assuming that you have the answer for element one. Then, try to solve it for elements one, two and three, assuming that you have the answer to elements one and two.
	+ Data Structure Brainstrom: This is hacky, but it often works. Simply run through a list of data structures and try to apply each one.